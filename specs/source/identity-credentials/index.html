<!DOCTYPE html>
<html>
  <head>
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>Identity Credentials 1.0</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <link rel="stylesheet" href="spec.css">
    <script src='//w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script src='../common/common.js' class='remove'></script>
    <script type="text/javascript" class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "CG-DRAFT",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "identity-credentials",

        // if you wish the publication date to be other than today, set this
        // publishDate:  "2009-08-06",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // extend the bibliography entries
        localBiblio: opencreds.localBiblio,

        issueBase: "https://github.com/opencreds/website/issues/",
        githubAPI: "https://api.github.com/repos/opencreds/website",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://opencreds.org/specs/source/identity-credentials/",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors:  [
          { name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar, Inc.", companyURL: "https://digitalbazaar.com/" },
          { name: "Dave Longley", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar, Inc.", companyURL: "https://digitalbazaar.com/"}
        ],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.
        authors:  [
            { name: "Manu Sporny", url: "https://digitalbazaar.com/",
              company: "Digital Bazaar, Inc.", companyURL: "https://digitalbazaar.com/" },
            { name: "Dave Longley", url: "https://digitalbazaar.com/",
              company: "Digital Bazaar, Inc.", companyURL: "https://digitalbazaar.com/"}
        ],

        // name of the WG
        wg:           "W3C Credentials Community Group",

        // URI of the public WG page
        wgURI:        "http://www.w3.org/community/credentials/",

        // name (with the @w3c.org) of the public mailing to which comments are due
        wgPublicList: "public-credentials",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
        // Team Contact.
        wgPatentURI:  "",
        maxTocLevel: 4,
        otherLinks: [{
          key: "Version control",
          data: [{
            value: "Github Repository",
            href: "https://github.com/opencreds/website"
          }, {
            value: "Issues",
            href: "https://github.com/opencreds/website/issues"
          }]
        }],
        inlineCSS: true,
        issueBase: "https://github.com/w3c/csvw/issues/",
      };
    </script>
    <script type="text/javascript" class="remove">
      var oldonload = window.onload;
      window.onload = function() {
        if (oldonload) oldonload();
        prettyPrint();
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
An <a>identity</a> is a collection of attributes about an entity that
distinguish it from other entities. Entities are anything with distinct
existence, such as people, organizations, concepts, or devices. Some entities,
such as people, are multifaceted, having multiple identities that they present
to the world. People are often able to establish trust by demonstrating that
others have made valuable claims about their identities. One way of doing this
is by presenting a <a>credential</a>. A <a>credential</a> is a set of
<a>claims</a> made by an <a>entity</a> about an <a>identity</a>. A
<a>credential</a> may refer to a qualification, achievement, quality, or other
information about an <a>identity</a> such as a name, government ID, home
address, or university degree that typically indicates suitability.
      </p>
      <p>
This specification describes how to express a digital <a>identity</a> and a
collection of digital <a>credentials</a> that assert <a>claims</a> about that
<a>identity</a>. It also describes a set of mechanisms for issuing and
requesting <a>credentials</a>.
      </p>
    </section>

    <section id='sotd'>
      <p>
This is an experimental specification that is attempting to unify the
work performed in the Credentials Community Group, the Web Payments Community
Group, the Linked Data community, the WebID Community Group, and the Mozilla
Persona team. As such, the specification borrows a number of concepts from each
group. It attempts to synthesize these concepts into a comprehensive solution
that can be easily implemented and deployed by Web developers in order to help
foster a rich ecosystem of digital identities and credentials on the Web.
      </p>

      <p class="issue">
This spec hasn't been updated in many months and the work has evolved quite
a bit since then. An update will occur as soon as other supporting documents
are in order and time permits. -- 9/24/15
      </p>

      <p class="issue">
Add a section specifying how blank nodes or pseudonyms can be used for
self-signed and IdP-asserted credentials.
      </p>

      <p class="issue">
Add a security/privacy consideration section that clearly marks out that
a single key should not be used for authentication at all websites and
that specifies how a different CryptographicKeyCredential can be generated
and signed by an IdP for every new origin visited. Add a note that this
approach is only for presenting identities that contain attributes that
are asserted by self-signed or IdP-asserted credentials.

This section should also detail best practices for creating a number of
separate identities that aggregate credentials asserted by different third
parties that are intended to be linked. There should be no doubt that this
system is engineered to support many different identities per individual user.
      </p>

    <p class="issue">
Add a section about revocation that also includes privacy concerns (leakage
of credential use at particular consumers to issuers). Specify how
credentials may self-describe their revocation rules and how issuers may
either publish revocation status credentials that can be aggregated over time
or on demand by IdPs or how they can periodically resign previously issued
credentials with new revocation validity periods (and these credentials can
then be refetched by users, IdPs, or authorized value-add third party services).
    </p>

    <p class="issue">
Add a section on the conversion of certain credentials, by anonymizer services,
to short-lived bearer credentials. These bearer credentials allow information
to be asserted with a level of trust that is dependent upon the anonymizer
service (which may actually be the same issuer that issued a credential), but
can be used to help enhance privacy.
    </p>

    <p class="issue">
Add a section on the use of ephemeral keys for public terminal use.
    </p>

    <p class="issue">
Add a section on integration with hardware security devices, FIDO, etc.
    </p>

    <p class="issue">
Add a section credential revocation. Indicate that credentials can specify
revocation policies/validity periods before revocation needs to be checked
again and that IdPs can fetch digitally-signed up-to-date credentials and/or
revocation information from issuers that can be forwarded to consumers
by the user agent (one privacy protecting mechanism for checking revocation).
    </p>

    </section>

    <section>
      <h2>Introduction</h2>
      <p>
An <a>identity</a> is a set of information that can be used to identify
a particular <a>entity</a>. Entities are anything with distinct existence,
such as a person, organization, concept, or device. We typically use
<a>credentials</a>, or claims made by others about our identities, to
authenticate ourselves and ultimately gain access to various services. For
example, we use email addresses to identify ourselves to online services,
driver's licenses to prove that we are capable of operating a motor vehicle,
university degrees to prove we are well-trained and knowledgeable, and
government-issued passports to travel between countries or to access financial
services. It is the goal of this specification to provide an easy, standard
way to express, issue, and consume identity credentials on the Web.
      </p>
      <p>
There are a number of desirable capabilities for credentials that have been
identified as requirements for this specification:
      </p>
      <ul>
        <li>
Credentials are user-centric. This refers to an architecture where:
          <ul>
            <li>
Credential holders are positioned in the middle between issuers and consumers.
            </li>
            <li>
Credential holders receive and store credentials from issuers through an
agent that the issuer does not need to trust.
            </li>
            <li>
Credential holders provide credentials to credential consumers through
an agent that consumers needn't trust; they only need to trust issuers.
            </li>
            <li>
Credentials are associated with identities, not particular services; credential
holders can decide how to aggregate credentials and manage their own
identities.
            </li>
            <li>
Credential holders can control and own their own identifiers.
            </li>
            <li>
Credential holders can control which credentials to use and when.
            </li>
            <li>
Credential holders may freely choose and swap out the agents they employ to
help them manage and share their credentials.
            </li>
            <li>
Credential holders that share verifiable claims are not required to reveal the
identity of the consumer to their agent or to issuers.
            </li>
          </ul>
        </li>
        <li>
A standard, machine-readable data format for expressing identity credentials
that can be extended with minimal coordination.
        </li>
        <li>
Independent issuance, storage, and cryptographic verification of credentials.
        </li>
        <li>
A standard mechanism for requesting credentials.
        </li>
        <li>
The ability to revoke previously issued credentials.
        </li>
        <li>
Web Browser APIs for storing and consuming credentials.
        </li>
      </ul>
      <p>
In order to store the unbounded variety of attributes that could be claimed
in identity credentials, a simple but extensible data model is utilized.
The specification uses a data storage and expression approach called
<a href="http://www.w3.org/TR/ld-glossary/#linked-data">Linked Data</a>. It
is a way of expressing information on the Web that is both simple and
extensible. Specifically, the Linked Data technology used by this specification
is JSON-LD [[!JSON-LD]].
      </p>
    </section>

    <section>
      <h2>Terminology</h2>

      <div data-include="../common/terms.html"
        data-oninclude="restrictReferences">
      </div>

    </section>

    <section>
      <h2>Expressing Identities and Credentials</h2>

      <p>
Any arbitrary information about an identity can be expressed using JSON-LD.
However, in order to express verifiable claims, credentials must be associated
with the identity. This section demonstrates how to express identities and
credentials.
      </p>

      <section>
        <h2>Expressing an Identity</h2>

        <p>
The following example demonstrates how to express a simple identity that
contains no independently verifiable claims. Each property of the identity,
such as <code>name</code> or <code>email</code>, is given context via
the <code>@context</code> value. Other contexts can be used or combined to
express any arbitrary information about an identity in idiomatic JSON.
        </p>

<pre class="example" title="A simple identity">{
  "@context": "https://w3id.org/identity/v1",
  "id": "did:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["Identity", "Person"],
  "name": "Alice Bobman",
  "email": "alice@example.com",
  "birthDate": "1985-12-14",
  "telephone": "12345678910"
}</pre>
      </section>

      <section>
        <h2>Expressing a Credential</h2>

        <p>
The following example demonstrates how to express a simple credential that
contains one verifiable claim about a particular identity. In this case, the
claim is that the <a>entity</a> with the <a>identity</a> identified by
<code>did:ebfeb1f712ebc6f1c276e12ec21</code> is 21 years of age or older. While
a human reading the property <code>ageOver</code> may be able to guess its
meaning by its name, the context maps it a global identifier (URL) where
a document could be retrieved that provides its semantics in a machine-readable
data format. There is also information about the credential itself, such
as an identifier for the entity that issued it and a date for when it was
issued. The credential contains a <code>signature</code> that can be used
to verify its entire contents, including the claim.
        </p>

<pre class="example" title="A simple credential">{
  "@context": "https://w3id.org/identity/v1",
  "id": "http://example.gov/credentials/3732",
  "type": ["Credential", "ProofOfAgeCredential"],
  "issuer": "https://dmv.example.gov",
  "issued": "2010-01-01",
  "claim": {
    "id": "did:ebfeb1f712ebc6f1c276e12ec21",
    "ageOver": 21
  },
  "signature": {
    "type": "LinkedDataSignature2015",
    "creator": "https://dmv.example.gov/keys/6",
    "signature": "2332f32g43ve23g23g23g/g3223gegvgre212fb488vh"
  }
}</pre>

        <p>
The following example demonstrates how to express a more complex credential that
contains some more verifiable claims about a particular identity.
        </p>

        <p class="issue">
TODO: Show use of another context to demonstrate decentralized extensibility.
        </p>

<pre class="example" title="A more complex credential">{
  "@context": "https://w3id.org/identity/v1",
  "id": "http://example.gov/credentials/3732",
  "type": ["Credential", "PassportCredential"],
  "name": "Passport",
  "issuer": "https://example.gov",
  "issued": "2010-01-01",
  "claim": {
    "id": "did:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Alice Bobman",
    "birthDate": "1985-12-14",
    "gender": "female",
    "nationality": {
      "name": "United States"
    },
    "address": {
      "type": "PostalAddress",
      "addressStreet": "372 Sumter Lane",
      "addressLocality": "Blackrock",
      "addressRegion": "Nevada",
      "postalCode": "237842",
      "addressCountry": "US"
    },
    "passport": {
      "type": "Passport",
      "name": "United States Passport",
      "documentId": "123-45-6789",
      "issuer": "https://example.gov",
      "issued": "2010-01-07T01:02:03Z",
      "expires": "2020-01-07T01:02:03Z"
    }
  },
  "signature": {
    "type": "LinkedDataSignature2015",
    "creator": "https://example.gov/keys/27",
    "signature": "3780eyfh3q0fhhfiq3q9f8ahsidfhf29rhaish"
  }
}</pre>
      </section>

      <section>
        <h2>Expressing Credentials in an Identity</h2>

        <p>
The following example demonstrates how to express one or more credentials along
with an identity. This approach allows one to express an identity and some
credentials that assert certain properties about it without losing data
fidelity. Because Linked Data is a graph-based format and credentials have been
digitally-signed as independent graphs of information, they are expressed using
the <code>@graph</code> keyword. An application that receives an
<a>identity</a> in this format can be ensured that the credential data won't be
accidentally mixed with data in any other graphs in the
<a>identity document</a>. Once the application has verified the digital
signatures in each credential, it can safely merge all of the claim data into a
single graph of information about the identity.
        </p>

<pre class="example" title="An identity with a credential">{
  "@context": "https://w3id.org/identity/v1",
  "id": "did:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["Identity", "Person"],
  "name": "Alice Bobman",
  "email": "alice@example.com",
  "birthDate": "1985-12-14",
  "telephone": "12345678910",
  "credential": [{
    "@graph": {
      "@context": "https://w3id.org/identity/v1",
      "id": "http://example.gov/credentials/3732",
      "type": ["Credential", "PassportCredential"],
      "name": "Passport",
      "issuer": "https://example.gov",
      "issued": "2010-01-01",
      "claim": {
        "id": "did:ebfeb1f712ebc6f1c276e12ec21",
        "name": "Alice Bobman",
        "birthDate": "1985-12-14",
        "gender": "female",
        "nationality": {
          "name": "United States"
        },
        "address": {
          "type": "PostalAddress",
          "addressStreet": "372 Sumter Lane",
          "addressLocality": "Blackrock",
          "addressRegion": "Nevada",
          "postalCode": "237842",
          "addressCountry": "US"
        },
        "passport": {
          "type": "Passport",
          "name": "United States Passport",
          "documentId": "123-45-6789",
          "issuer": "https://example.gov",
          "issued": "2010-01-07T01:02:03Z",
          "expires": "2020-01-07T01:02:03Z"
        }
      },
      "signature": {
        "type": "LinkedDataSignature2015",
        "creator": "https://example.gov/keys/27",
        "signature": "3780eyfh3q0fhhfiq3q9f8ahsidfhf29rhaish"
      }
    }
  }]
}</pre>
      </section>
    </section>

    <section>
      <h2>Identity Providers</h2>

      <p class="issue">
The term Identity Provider may be too overloaded at this point. In other
systems such as SAML and OpenID Connect, identity providers essentially double
as issuers and what this spec refers to as identity providers. Because
this spec's view of an identity provider is more limited (it is more like
a simple identity agent), perhaps another term would be more fitting and
reduce confusion when comparing architectures.
      </p>

      <p>
An <a>identity provider</a> is a software service that acts as an agent for
a credential holder. It helps the credential holder manage one or more of
their <a>identities</a> and their associated <a>credentials</a>. It does
not typically act as an <a>issuer</a>. For the purpose of this specification,
its primary utility is to implement standard APIs to allow the storage and
retrieval of <a>credentials</a>.
      </p>

      <p>
A credential holder may specify the URL to their <a>identity provider</a>
in their <a>identity document</a>. This URL can be retrieved to determine
the service endpoints for the <a>identity provider</a>.
      </p>

      <p class="issue">
Specify the service endpoints that an IdP should/must define. Include that it
can optionally provide a credential management URL. Indicate that how an IdP
decides to authenticate a user whose user agent visits its credential
management URL is out-of-scope.
      </p>

<pre class="example" title="An identity with a specified identity provider">{
  "@context": "https://w3id.org/identity/v1",
  "id": "did:ebfeb1f712ebc6f1c276e12ec21",
  "type": "Identity",
  "idp": "https://idp.example.com"
}</pre>

      <p class="issue">
Show example of JSON-LD document that is returned when querying IDP url.
      </p>

<!-- TODO: clearly articulate layering w/DIDs/WebDHT (refer to WebDHT spec) -->
  </section>

  <section>
    <h1>Getting and Storing Identity Credentials</h1>

    <p>
There are two mechanisms that allow access an Identity's credentials. The first
is mechanism that allows an authorized client to access credentials via an
HTTP API. HTTP API clients are granted authorization by authenticating with an
HTTP Signature [[!HTTP-SIGNATURES]] or by using a macaroon [[!Macaroons]]. The
second mechanism is to use a browser-based API that extends Credential
Management Level 1 [[!CREDENTIAL-MANAGEMENT]] and allows the identity owner to
interactively decide which credentials to share.
    </p>

    <p class="issue">
Consider adding, to the new HTTP API section, a flow with 4xx Credentials
Required (if Authorization Required doesn't fit) with a response that includes
a location to get a credentials query, which when fulfilled via a POST to
an endpoint, will result in a macaroon. The macaroon can then be used to
access a resource or be attenuated and given out to delegate access.
    </p>

    <section>
      <h2>HTTP API</h2>

      <p>
The HTTP API can be used to store or get an identity containing credentials. In
for a client to be authorized to use the HTTP API it must either be
pre-authorized and use HTTP Signatures [[!HTTP-SIGNATURES]] to authenticate or
it must possess an appropriate macaroon.
      </p>

      <p class="issue">
Add section for authenticating to the various endpoints using plain
HTTP Signatures [[!HTTP-SIGNATURES]] (no macaroon) for pre-authorized clients.
      </p>

      <section>
        <h2>Getting a Macaroon</h2>

        <p>
The only entity that is automatically authorized to store or get an identity
with credentials from an <a>identity provider</a> is the entity that is
identified by the identity. This entity may directly access the HTTP API by
authenticating with an HTTP Signature [[!HTTP-SIGNATURES]] or it may request a
macaroon that can be attenuated to delegate authorization to another party. To
get a macaroon a client must:
        </p>

        <ol class="algorithm">
          <li>
Get the identifier for the <a>identity's</a> <a>identity provider</a> from
its <a>identity document</a>.
          </li>
          <li>
Dereference the <a>identity provider's</a> identifier.
          </li>
          <li>
Get the <a>identity provider's</a> <em>macaroon factory URL</em> from
its <a>identity document</a>.
          </li>
          <li>
Request a macaroon from the <em>macaroon factory URL</em>, authenticating with
an HTTP Signature [[!HTTP-SIGNATURES]] or some other mechanism (eg: a cookie).
          </li>
        </ol>

        <p>
The retrieved macaroon grants full authorization to both the get and store
endpoints for the <a>identity</a>. It should be attenuated prior to delegating
authorization to a third party. For example, the following caveats could be
added to the macaroon: an expiration date, the specific types of credentials
that can be retrieved, and a requirement to provide a credential that
authenticates the user of the macaroon as being identified by a particular
identity.
        </p>
      </section>

      <p class="issue">
The following subsections are very high-level, incomplete, and rough. Add
details.
      </p>

      <section>
        <h2>Storing Credentials</h2>

        <p>
New credentials can be stored at an <a>identity provider</a> via its HTTP API.
To store credentials using this mechanism, a client must follow this algorithm:
        </p>

        <ol class="algorithm">
          <li>
Get the identifier for the <a>identity's</a> <a>identity provider</a> from
its <a>identity document</a>.
          </li>
          <li>
Dereference the <a>identity provider's</a> identifier.
          </li>
          <li>
Get the <a>identity provider's</a> <em>credential storage URL</em> from
its <a>identity document</a>.
          </li>
          <li>
Perform an HTTP POST to the <em>credential storage URL</em> with the
identity containing the credentials to store as the body of the request and
a macaroon as a cookie.
          </li>
          <li>
The response will be an acknowledgement of storage.
          </li>
        </ol>
      </section>

      <section>
        <h2>Getting Credentials</h2>

        <p>
A "view" of an identity can be requested by querying for certain attributes
or particular types of credentials from an <a>identity provider</a> via its
HTTP API. To get credentials using this mechanism, a client must follow this
algorithm:
        </p>

        <p class="issue">
Add section detailing what a credential query looks like and how to process
it.
        </p>

        <ol class="algorithm">
          <li>
Get the identifier for the <a>identity's</a> <a>identity provider</a> from
its <a>identity document</a>.
          </li>
          <li>
Dereference the <a>identity provider's</a> identifier.
          </li>
          <li>
Get the <a>identity provider's</a> <em>credential query URL</em> from
its <a>identity document</a>.
          </li>
          <li>
Perform an HTTP POST to the <em>credential query URL</em> with the
credential query as the body of the request and a macaroon as a cookie.
          </li>
          <li>
The response body will be an <a>identity</a> containing any credentials that
match the query.
          </li>
        </ol>
      </section>
    </section>

    <section>
      <h2>Extension to Credential Management API</h2>

      <p>
This section of this specification describes an extension to
[[!CREDENTIAL-MANAGEMENT]].
      </p>

      <p class="issue">
This section needs a lot of detail added to it. It currently only shows a
very high level view of the extensions. More details about how this spec
extends [[!CREDENTIAL-MANAGEMENT]] are needed, for an implementation, see:
https://github.com/digitalbazaar/credentials-polyfill
      </p>

      <section>
        <h2>IdentityCredential</h2>

        <p>
This specification adds a new type of credential, <code>IdentityCredential</code>:
        </p>

        <pre class="idl">
[Constructor(dictionary identity), Exposed=Window]
interface IdentityCredential : Credential {
  readonly attribute dictionary identity;

  static Promise&lt;any&gt; register(dictionary options);
};
        </pre>

        <p>
An <a>identity provider</a> may pass its identifier to the
<code>register</code> method to ask the user agent to help the
user register the <a>identity provider</a> with one of their identities.
        </p>

        <p class="issue">
Provide more details about <code>register</code>. Indicate a new identity
can be created by the user or an existing one can be used. Specify valid
options, return value, and expected behavior for IdP.
        </p>

      </section>

      <section>
        <h2>Storing an IdentityCredential</h2>

        <p>
When storing an <code>IdentityCredential</code>, <var>credential</var>, via
<em>navigator.credentials.store</em>, the user agent must follow this algorithm:
        </p>

        <p class="issue">
Provide steps for dealing with ensuring the user has a public/private key pair
on their device that matches <var>credential.identity</var>. If one doesn't
yet exist, provide steps for generating one.
        </p>

        <ol class="algorithm">
          <li>
Dereference the <code>id</code> property of <var>credential</var> to get
the <a>identity document</a>.
          </li>
          <li>
Get the identifier for the <a>identity's</a> <a>identity provider</a> from
the <a>identity document</a>.
          </li>
          <li>
Dereference the <a>identity provider's</a> identifier.
          </li>
          <li>
Get the <a>identity provider's</a> <em>credential management URL</em> from
its <a>identity document</a>.
          </li>
          <li>
Create a pending <em>CredentialOperation</em>, <var>operation</var>. Set its
<em>name</em> to <code>store</code>, its <em>options.store</em> to
<var>credential.identity</var>, and its <em>identity</em> to a
digitally-signed copy of the identity matching <var>credential.identity</var>
along with a <code>CryptographicKeyCredential</code> containing a self-signed
public key. When this <em>CredentialOperation</em> is completed, the promise
associated with <em>navigator.credentials.store</em> will be resolved.
          </li>
          <li>
Open a new, secure, browsing context and request the
<em>credential management URL</em>.
          </li>
          <li>
Wait for the <a>identity provider</a> to complete the operation.
          </li>
        </ol>

        <p class="issue">
Spec out an alternative approach where the <a>identity provider</a> elects to
have the user agent provide the UI for storing the IdentityCredential; the user
agent uses the <a>identity provider's</a> HTTP API to ultimately store the
IdentityCredential.
        </p>

        <img id="diagram-writing" alt="Creating a Credential"
          style="display: block; margin-left: auto; margin-right: auto;
          max-height:100%; max-width:50%;" src="basicCredentialCreation.svg">
      </section>

      <section>
        <h2>Getting an IdentityCredential</h2>

        <p>
When getting an <code>IdentityCredential</code>, via
<em>navigator.credentials.get</em>, the user agent must follow this algorithm:
        </p>

        <p class="issue">
Provide steps for allowing a user to register an existing identity to their
user agent.
        </p>

        <ol class="algorithm">
          <li>
Show an identity chooser that allows the user to select the identity
they would like to use to fulfill the request. They may also register an
existing identity with the user agent if the desired entity cannot be found
with the chooser (ie: the identity was created with another device).
          </li>
          <li>
After the user selects an identity, get the identifier for the
<a>identity's</a> <a>identity provider</a> from its <a>identity document</a>.
          </li>
          <li>
Dereference the <a>identity provider's</a> identifier.
          </li>
          <li>
Get the <a>identity provider's</a> <em>credential management URL</em> from
its <a>identity document</a>.
          </li>
          <li>
Create a pending <em>CredentialOperation</em>, <var>operation</var>. Set its
<em>name</em> to <code>get</code>, its <em>options.query</em> to the
query passed in the options for <em>navigator.credentials.get</em>, and its
<em>identity</em> to a digitally-signed copy of the identity selected
along with a <code>CryptographicKeyCredential</code> containing a self-signed
public key. When this <em>CredentialOperation</em> is completed, the promise
associated with <em>navigator.credentials.get</em> will be resolved.
          </li>
          <li>
Open a new, secure, browsing context and request the
<em>credential management URL</em>.
          </li>
          <li>
Wait for the <a>identity provider</a> to complete the operation.
          </li>
        </ol>

        <p class="issue">
Spec out an alternative approach where the <a>identity provider</a> elects to
have the user agent provide the UI for getting the IdentityCredential; the user
agent uses the <a>identity provider's</a> HTTP API to process the query and
retrieve any data that must be shown on the UI.
        </p>

        <p class="issue">
Add section detailing how the browser can synthesize a
CryptographicKeyCredential for simple website login.
        </p>

        <img id="diagram-reading" alt="Basic Credential Flow"
          style="display: block; margin-left: auto; margin-right: auto;
          max-height:100%; max-width:50%;" src="basicCredentialFlow.svg">
      </section>
    </section>

<!--
       <p>
The table below summarizes the HTTP Signatures-based [[!HTTP-SIGNATURES]]
mechanism of accessing and modifying an identity:
      </p>

      <table>
        <thead>
          <tr>
            <th style="white-space: nowrap;">HTTP Method</th>
            <th>Description of Action</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>GET</td>
            <td>
Read all of the information that is available to the <a>credential consumer</a>.
Note: This may only be a subset of all of the information based on the level
of access the <a>credential consumer</a> has to certain attributes in the resource.
            </td>
          </tr>
          <tr>
            <td>POST</td>
            <td>
Used to perform operations on the identity for applications that are not
capable of using HTTP Signatures [[!HTTP-SIGNATURES]] or to perform specific
queries on the identity data.
            </td>
          </tr>
          <tr>
            <td>PATCH</td>
            <td>
Modify information in the identity using the JSON Patch [[!JSON-PATCH]]
protocol.
            </td>
          </tr>
          <tr>
            <td>PUT</td>
            <td>
Replace the entire identity with the provided identity document. This operation
SHOULD only be accessible to the owner of the identity.
            </td>
          </tr>
          <tr>
            <td>DELETE</td>
            <td>
Deletes the identity. This operation SHOULD only be accessible to the owner of
the identity.
            </td>
          </tr>
        </tbody>
      </table>
-->

    <!-- <section>
      <h2>Integration with OpenID, OAuth1, and OAuth2</h2>
      <p class="issue" data-number="8"></p>
    </section> -->

<!--
        <p>
Once the <a>credential consumer</a> has tried to access a protected resource,
the website can request a particular set of credentials from the customer:
        </p>
        <pre class="example" title="A request to read citizenship information from an identity">
POST /credentials-query HTTP/1.1
Host: idp.example.com
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "id": "",
  "name": "",
  "governmentId": "",
  "birthdate": ""
}</pre>
        <p>
The result of the POST request will be a dialog that the
<a>identity provider</a> displays to the <a>identity owner</a>
asking them to verify the information that will be transmitted to the
<a>credential consumer</a>. The mechanism used to present this dialog to the
<a>identity owner</a> is outside of the scope of this specification.
The result of a successful interaction with the verification dialog will be
a POST back to the callback URL provided by the <a>credential consumer</a>:
        </p>
        <pre class="example" title="A successful response to an interactive request for citizenship information from an identity">
POST /verify?session=7f8nddn HTTP/1.1
Host: flights.example.org
Date: Tue, 07 Jun 2013 20:53:28 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.org/identities/alice",
  "type": ["Identity", "Person"],
  "name": "Alice Smith",
  "birthdate": "1988-11-02",
  "governmentId": "321-54-9876"
  "credential": [{
    "id": "http://ssa.us.gov/credential/8273",
    "type": "PassportCredential",
    "claim": {
      "id": "https://example.org/identities/alice",
      "name": "Alice Smith",
      "birthdate": "1988-11-02",
      "governmentId": "321-54-9876"
    },
    "expires": "2017-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://ssa.us.gov/keys/27",
       "signature": "fhhfiq3q9f8ahfh3q029rhaishsidfhf3780ey"
    }
  }]
}
        </pre>
        <p>
As the response above shows, the <a>identity owner</a> accepted the
request for information and the <a>identity provider</a> has performed
a POST to the callback URL provided by the <a>credential consumer</a> via the
<a>identity owner's</a> web browser. Since the request included the
<code>credentials=true</code> flag, the credentials for the information
requested have been included so that the <a>credential consumer</a> may
validate the information against the third party credentials.
        </p>
      </section>

      <section>
        <h2>Credentials and Claims</h2>
        <p>
It is possible for a third party to provide digitally signed credentials to be
stored with an identity. For example, if an individual would like to store
digitally signed credentials verifiying their citizenship information, they
would go through the following process:
        </p>
        <ol>
          <li>Go to a government website and start the verification process.</li>
          <li>Provide their identity URL to the government website.</li>
          <li>The government website would digitally sign a credential and attempt to write it to the provided identity.</li>
          <li>The individual would be provided with a dialog to authorize the write of the credential to their identity.</li>
          <li>If the authorization is successful, the digitally signed credential is written to the identity and will be returned in future queries for such a credential.</li>
        </ol>
      </section>

      <section>
       <h2>Storing a credential</h2>
       <p class="issue">
Rewrite section to focus on storing credentials.
       </p>

       <p>
There are two mechanisms that allow a third party to write information
to an <a>identity document</a>. The first is an HTTP Signature
[[!HTTP-SIGNATURES]] based mechanism that allows any authorized
client to write data that has been pre-approved by the entity that controls
access to the identity information. The second is to use a browser-based
mechanism that POSTs a patch request to an <a>identity document</a>,
allowing the <a>identity owner</a> to interactively decide what data
to write to the <a>identity document</a>.
        </p>

        <p>
The example below demonstrates a digitally signed request to write information
to a specific <a>identity document</a> using an HTTP Signature:
        </p>

        <pre class="example" title="An attempt to write identity information using HTTP Signature-based authentication">
POST /identities/alice?action=patch HTTP/1.1
Host: example.org
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/json-patch+json
Authorization: Signature
  keyId="https://ssa.us.gov/keys/27",
  algorithm="rsa-sha256",
  headers="(request-line) host date content-type",
  signature="Gm7W/r+e90REDpWyt.../VebAsNUtvQMe6cTjnDY="

{
  "op": "add",
  "path": "https://w3id.org/identity#credential",
  "value": {
    "@context": "https://w3id.org/identity/v1",
    "id": "http://ssa.us.gov/credential/8273",
    "type": "PassportCredential",
    "claim": {
      "id": "https://example.org/identities/alice",
      "name": "Alice Smith",
      "birthdate": "1988-11-02",
      "governmentId": "321-54-9876"
    },
    "expires": "2017-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://ssa.us.gov/keys/27",
       "signature": "r+e90REDpW....bAsNUtvQM"
    }
  }
}
        </pre>

        <p>
The example below demonstrates an unsigned request to write information
to a specific <a>identity document</a>. Since the request is unsigned,
the <a>identity provider</a> would initiate an interactive authorization
where the <a>identity owner</a> would verify that the information to
be written is acceptable. The specifics of the interactive authorization flow
are outside the scope of this document, but are roughly outlined in the diagram
below:

<img id="diagram-writing" alt="Creating a Credential"
  style="display: block; margin-left: auto; margin-right: auto;
  max-height:100%; max-width:50%;" src="basicCredentialCreation.svg">
        </p>

        <p>
The data that is sent back and forth is outlined below:
        </p>

        <pre class="example" title="An unsigned attempt to write identity information to an identity document">
POST /create?action=patch HTTP/1.1
Host: login-hub.com
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/json-patch+json
{
  "op": "add",
  "path": "https://w3id.org/identity#credential",
  "value": {
    "@context": "https://w3id.org/identity/v1",
    "id": "http://ssa.us.gov/credential/8273",
    "type": "PassportCredential",
    "claim": {
      "id": "https://example.org/identities/alice",
      "name": "Alice Smith",
      "birthdate": "1988-11-02",
      "governmentId": "321-54-9876"
    },
    "expires": "2017-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://ssa.us.gov/keys/27",
       "signature": "r+e90REDpW....bAsNUtvQM"
    }
  }
}
        </pre>
        <p>
The format for the message above is JSON-PATCH where the <code>path</code>
value is the complete URL for JSON-LD property to add to the
<a>identity document</a>.
        </p>
      </section>

    </section>

    <section>
      <h1>Web Credential-based Login</h1>
      <p>
It is possible to use the mechanism described in this specification to login to
a website in much the same way that Persona enables a verified email login. The
process is described below:
      </p>
      <ol>
        <li>
Go to a website that requires a valid email address for login.
        </li>
        <li>
The website requests the email address for login.
        </li>
        <li>
A document is fetched from the domain of the email address checking for a
Web Identity endpoint and identity service URL.
        </li>
        <li>
The user agent is instructed to retrieve the credential information from the
Web Identity endpoint and send it to the website requiring login.
        </li>
        <li>
The website that requires the valid email address for login checks the
credentials posted by the user agent, verifies the signatures, and creates a
session for the user.
        </li>
      </ol>

      <p>
The diagram below outlines the basic login flow described above.
<img id="diagram-login" alt="Basic Login Flow"
  style="display: block; margin-left: auto; margin-right: auto;
  max-height:100%; max-width:50%;" src="basicCredentialFlow.svg">
      </p>

      <section>
        <h2>Detailed Flow for Credential-based Login</h2>
        <p class="issue" data-number="7"></p>
        <p>
In the following example, a login prompt is provided on
<code>store.example.org</code> where the person that is logging in provides
the <code>asmith@example.com</code> email address. The first step constitutes
<code>store.example.org</code> fetching the identity endpoint information
from <code>example.com</code>:
        </p>
        <pre class="example" title="Step 1a: Web Identity endpoint requested">
GET /.well-known/identity HTTP/1.1
Host: example.com
Date: Wed, 08 Jun 2013 22:54:42 GMT
Content-Type: application/ld+json
        </pre>
        <p>
A successful retrieval of the identity service endpoint will result in the
following document:
        </p>
        <pre class="example" title="Step 1b: Web Identity endpoint document retrieved">
HTTP/1.1 200 OK
Content-Type: application/ld+json
Content-Length: 34
Date: Wed, 08 Jun 2013 22:54:43 GMT

{
  "@context": "https://w3id.org/identity/v1",
  "identityService": "https://example.com/identities"
}
        </pre>
        <p>
The <code>store.example.org</code> software may then construct the proper query
to the identity service:
        </p>
        <pre class="example" title="Step 2a: Request verified e-mail information">
POST /identities?action=query&amp;credentials=true&amp;callback=https://store.example.org/verify?session=8d73j320s HTTP/1.1
Host: example.com
Date: Wed, 08 Jun 2013 22:54:44 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "email": "asmith@example.com"
}
        </pre>
        <p>
After a UI interaction with Alice on <code>example.com</code> verifies that
the email information should be sent to <code>store.example.org</code>,
the following message is transmitted from Alice's user agent to
<code>store.example.org</code>:
        </p>
        <pre class="example" title="Step 2b: Request for e-mail information is fulfilled">
POST https://store.example.org/verify?session=8d73j320s HTTP/1.1
Host: example.org
Date: Wed, 08 Jun 2013 22:55:15 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.com/identities/asmith",
  "type": "Identity",
  "email": "asmith@example.com",
  "credential": [{
    "id": "http://example.com/credentials/23894",
    "type": "EmailCredential",
    "claim": {
      "id": "https://example.com/identities/asmith",
      "email": "asmith@example.com",
    },
    "expires": "2015-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://example.com/keys/24",
       "signature": "jf48901fu41...23908aszfhdk23h9f"
    }
  }]
}
        </pre>
        <p class="note">
Note that for the purposes of simplicity in the example above, there is
no tracking protection to prevent <code>example.com</code> from knowing which
website Alice is logging in to. Tracking protection is easily implemented by
adding a trusted third party, such as the browser UI or a third party mixer service,
that decouples the identity provider from the relying party.
        </p>
      </section>
    </section>

    <section>
      <h1>Compatibility with other Login Mechanisms</h1>
      <p>
This identity mechanism is designed to be compatible with other identity
mechanisms in use today such as OpenID, Facebook Connect, and Firefox ID.
      </p>
      <section>
        <h2>Integration with Mozilla Persona / Firefox ID</h2>
        <p>
The identity mechanism is such that it can be returned in a
Mozilla Persona or FxID-based login. The assertion returned to the FxID-enabled
website would contain an identity URL which would be compatible with this
specification. This allows both the basic email address to the validated, and
extension information (such as citizenship information, age assertions) to be
discoverable after the login.
        </p>
        <pre class="example" title="Example of a Mozilla Persona login assertion that also includes the identity URL of the entity">
{
  "public-key": {
    "algorithm": "DS",
    "y": "8e65e949e2e...1263ea6",
    "p": "ff600483dab...7fc26d0",
    "q": "e21e04f91d1...ecaab3b",
    "g": "c52a4a0ff34...233397a"
  },
  "principal": {
    "@context": "https://w3id.org/identity/v1",
    "email": "asmith@example.org",
    "identity": "https://example.org/identities/alice"   &lt;--- This bootstraps the identity assertion discovery process
  },
  "iat": 1392697368513,
  "exp": 1392783768513,
  "iss": "example.org"
}</pre>
      </section>

    </section>
-->
  </body>
</html>

